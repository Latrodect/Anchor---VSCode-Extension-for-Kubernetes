{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://compose-core/./src/commands/generateDockerComposeYaml.ts","webpack://compose-core/./src/commands/generateDockerFiles.ts","webpack://compose-core/./src/commands/generateInlineCommands.ts","webpack://compose-core/./src/commands/generateKubernetesFiles.ts","webpack://compose-core/./src/extension.ts","webpack://compose-core/./src/utils/inlineComments.ts","webpack://compose-core/external commonjs \"vscode\"","webpack://compose-core/external node-commonjs \"fs\"","webpack://compose-core/external node-commonjs \"path\"","webpack://compose-core/webpack/bootstrap","webpack://compose-core/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport async function generateDockerComposeYaml(autorunBool: boolean) {\r\n    interface DockerService {\r\n        build: {\r\n          context: string;\r\n          dockerfile: string;\r\n        };\r\n        ports: string[];\r\n        volumes: string[];\r\n        environment: string[];\r\n      }\r\n      \r\n      interface DockerComposeData {\r\n        version: string;\r\n        services: Record<string, DockerService>;\r\n      }\r\n\r\n    if (!vscode.workspace.workspaceFolders) {\r\n        vscode.window.showErrorMessage('No workspace is open.');\r\n        return;\r\n    }\r\n    \r\n    const inputServiceCount = await vscode.window.showInputBox({\r\n        prompt: 'How many service do you want to use:',\r\n        placeHolder: 'Example Usage: 6',\r\n    });\r\n\r\n    if (!inputServiceCount || inputServiceCount.trim() === \"\") {\r\n        vscode.window.showErrorMessage('Please provide how many service do you have.');\r\n        return;\r\n    }\r\n\r\n    const serviceCount = parseInt(inputServiceCount, 10);\r\n\r\n    if (Number.isNaN(serviceCount) || serviceCount <= 0 ) {\r\n      vscode.window.showErrorMessage('Please provide a valid positive number of services.');\r\n      return;\r\n   }\r\n\r\n   if( serviceCount >= 150){\r\n    vscode.window.showWarningMessage('Too many services. Extension can be crash and generating your files takes too much time!');\r\n    }\r\n\r\n    let serviceList = []\r\n    let envList = []\r\n\r\n    for (let index = 0; index < serviceCount; index++) {\r\n      const serviceInformation = await vscode.window.showInputBox({\r\n        prompt: 'Service Information:',\r\n        placeHolder: 'Example Usage: frontend(Service Name), 8000(Service Port)',\r\n      });\r\n    \r\n      if (!serviceInformation || inputServiceCount.trim() === \"\") {\r\n        \r\n        vscode.window.showErrorMessage('Please provide your service information.');\r\n        return;\r\n      }\r\n      \r\n      const service = checkSpacesAndReplace(serviceInformation.split(',').map(name => name.trim()));\r\n\r\n      if (service.length !== 2) {\r\n        vscode.window.showErrorMessage('Please provide service information in the correct format: \"Service Name, Service Port\".');\r\n        return;\r\n    }\r\n\r\n      let environmentVariables = await vscode.window.showInputBox({\r\n        prompt: 'Specify Environment Variables:',\r\n        placeHolder: 'Example Usage: mongo_host: 127.0.0.1, mongo_port: 4000, ...',\r\n      });\r\n\r\n      if (!environmentVariables || environmentVariables.trim() === \"\") {\r\n        vscode.window.showInformationMessage('Default item setted to environment variables.');\r\n        environmentVariables = \"env_var=default\";\r\n      }\r\n\r\n      const environmentVars = checkSpacesAndReplace(environmentVariables.split(',').map(name => name.trim()));\r\n      const formattedEnvironmentVar = createEnvironmentVariables(environmentVars);\r\n\r\n    serviceList.push(service);\r\n    envList.push(formattedEnvironmentVar);\r\n    }\r\n\r\n    const dockerComposeFolder = vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, 'docker_compose');\r\n    fs.mkdirSync(dockerComposeFolder.fsPath, { recursive: true });\r\n    \r\n    const dockerComposeData: DockerComposeData = {\r\n      version: '3',\r\n      services: {}\r\n    };\r\n    \r\n    for (let index = 0; index < serviceList.length; index++) {\r\n      const [serviceName, port] = serviceList[index];\r\n      const environmentEntries = envList[index];\r\n    \r\n      const formattedEnvironmentStrings = environmentEntries.map(entry => `${entry}`).join('\\n      ');\r\n\r\n      dockerComposeData.services[serviceName] = {\r\n        build: {\r\n          context: `./path/to/${serviceName}`,\r\n          dockerfile: 'Dockerfile'\r\n        },\r\n        ports: [`${port}:${port}`],\r\n        volumes: [`./path/to/${serviceName}:/app/src/${serviceName}`],\r\n        environment: [\r\n          formattedEnvironmentStrings\r\n        ]\r\n      };\r\n    }\r\n      \r\n      const yamlContent = `\r\nversion: '${dockerComposeData.version}'\r\nservices:\r\n${Object.entries(dockerComposeData.services)\r\n        .map(([serviceName, serviceData]) => `  \r\n  ${serviceName}:\r\n    build:\r\n      context: ${serviceData.build.context}\r\n      dockerfile: ${serviceData.build.dockerfile}\r\n    ports:\r\n      - \"${serviceData.ports[0]}\"\r\n    volumes:\r\n      - \"${serviceData.volumes[0]}\"\r\n    environment:\r\n      ${serviceData.environment[0]}`)\r\n        .join('\\n')}`;\r\n\r\n    const dockerComposeYamlPath = path.join(dockerComposeFolder.fsPath, 'docker-compose.yaml');\r\n    await writeFileWithDirectoryCheck(dockerComposeYamlPath, yamlContent);\r\n\r\n    const config = vscode.workspace.getConfiguration('compose-core');\r\n    const dockerComposeAutorun = config.get('dockerComposeAutorun');\r\n\r\n    if (dockerComposeAutorun === true) {\r\n      console.log('Running Docker Compose...');\r\n      const workspaceDir = dockerComposeFolder.fsPath; \r\n      const terminal = vscode.window.createTerminal({\r\n        name: 'Cmd in Workspace',\r\n        cwd: workspaceDir, \r\n      });\r\n\r\n      terminal.sendText('docker compose up docker-compose.yaml');\r\n      terminal.show();\r\n      }\r\n    \r\n}\r\nasync function writeFileWithDirectoryCheck(filePath: string, content: string) {\r\n    const folderPath = path.dirname(filePath);\r\n    await fs.promises.mkdir(folderPath, { recursive: true });\r\n    await fs.promises.writeFile(filePath, content);\r\n}\r\n\r\nfunction createEnvironmentVariables(environmentVars: string[]): string[] {\r\n  return environmentVars.map(varName => `- ${varName}=${process.env[varName] || 'default'}`);\r\n}\r\n\r\nfunction checkSpacesAndReplace(variableList: string[]){\r\n  return variableList.map((item) => item.replace(/ +/g, '_'))\r\n}\r\n\r\nmodule.exports = {\r\n  generateDockerComposeYaml\r\n};","import * as vscode from 'vscode';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport async function generateDockerFiles() {\r\n    if (!vscode.workspace.workspaceFolders) {\r\n        vscode.window.showErrorMessage('No workspace is open.');\r\n        return;\r\n    }\r\n\r\n    const projectRoot = await vscode.window.showInputBox({\r\n        prompt: 'Root of your project:',\r\n        placeHolder: 'Example Usage: D:/MyProject/src',\r\n    });\r\n\r\n    const contApplicaitons = await vscode.window.showInputBox({\r\n        prompt: 'Your Apps:',\r\n        placeHolder: 'Example Usage(application folder names): frontned, backend, sync',\r\n    });\r\n\r\n    if (!contApplicaitons) {\r\n        vscode.window.showWarningMessage('Please specify at least one application path.');\r\n        return;\r\n    }\r\n\r\n    if (!projectRoot) {\r\n        vscode.window.showWarningMessage('Please provide root path.');\r\n        return;\r\n    }\r\n\r\n    const dockerFolder = vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, 'docker');\r\n    fs.mkdirSync(dockerFolder.fsPath, { recursive: true });\r\n\r\n    const scriptsFolder = vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, 'scripts');\r\n    fs.mkdirSync(scriptsFolder.fsPath, { recursive: true });\r\n\r\n    const dockerApplicationsPath = checkSpacesAndReplace(contApplicaitons.split(',').map(name => \"../docker/\" + name.trim()+\"/Dockerfile\"));\r\n\r\n    const scriptContent = `\r\n#!/bin/bash\r\n\r\n# Define the applications and their Dockerfile paths\r\nAPPLICATIONS=(${contApplicaitons})\r\nDOCKERFILES=(\"${dockerApplicationsPath}\")\r\n\r\n# Loop through each application and build the Docker image\r\nfor ((i=0; i<\\${#APPLICATIONS[@]}; i++)); do\r\n    APP_NAME=\"\\${APPLICATIONS[$i]}\"\r\n    DOCKERFILE=\"\\${DOCKERFILES[$i]}\"\r\n    echo \"Building Docker image for $APP_NAME...\"\r\n    \r\n    # Check if the Dockerfile exists\r\n    if [ ! -f \"$DOCKERFILE\" ]; then\r\n        echo \"Dockerfile not found for $APP_NAME.\"\r\n        continue\r\n    fi\r\n    \r\n    # Build the Docker image\r\n    docker build -t \"$APP_NAME:latest\" -f \"$DOCKERFILE\" .\r\n    \r\n    echo \"Docker image for $APP_NAME built.\"\r\n    echo\r\ndone\r\n\r\necho \"All Docker images built.\"\r\n`\r\n    const scriptFilePath = path.join(scriptsFolder.fsPath, 'docker_build_image.bash');\r\n            await writeFileWithDirectoryCheck(scriptFilePath, scriptContent);\r\n\r\n    const dockerApplications = checkSpacesAndReplace(contApplicaitons.split(',').map(name => name.trim()));\r\n\r\n    for (const appName of dockerApplications) {\r\n        const appFolder = vscode.Uri.joinPath(dockerFolder, appName);\r\n        fs.mkdirSync(appFolder.fsPath, { recursive: true });\r\n\r\n        const folderPath = findApplicationFolder(projectRoot, appName);\r\n        if (folderPath) {\r\n            const dockerFileContent = `\r\n# Use a base image\r\nFROM node:14\r\n\r\n# Set the working directory inside the container\r\nWORKDIR /app\r\n\r\n# Install dependencies\r\nRUN npm install\r\n\r\n# Copy the rest of the application code to the container\r\nCOPY ${folderPath} ./src/${appName}\r\n\r\n# Expose a port (if needed)\r\nEXPOSE 3000\r\n\r\n# Specify the command to run when the container starts\r\nCMD [\"npm run start\"]\r\n                                    `;\r\n\r\n            const dockerFilePath = path.join(appFolder.fsPath, 'Dockerfile');\r\n            await writeFileWithDirectoryCheck(dockerFilePath, dockerFileContent);\r\n        }\r\n    }\r\n}\r\n\r\nasync function writeFileWithDirectoryCheck(filePath: string, content: string) {\r\n    const folderPath = path.dirname(filePath);\r\n    await fs.promises.mkdir(folderPath, { recursive: true });\r\n    await fs.promises.writeFile(filePath, content);\r\n}\r\n\r\nfunction findApplicationFolder(projectRoot: string, applicationName: string): string | undefined {\r\n  const folderPath = path.join(projectRoot, applicationName);\r\n\r\n  try {\r\n      const stat = fs.statSync(folderPath);\r\n      if (stat.isDirectory()) {\r\n          return folderPath;\r\n      }\r\n  } catch (error) {\r\n    vscode.window.showWarningMessage('Folder does not exist.');\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction checkSpacesAndReplace(variableList: string[]){\r\n    return variableList.map((item) => item.replace(/ +/g, '_'))\r\n  }","import * as vscode from 'vscode';\r\nimport { generateInlineComments } from '../utils/inlineComments';\r\n\r\nexport function generateInlineCommands() {\r\n    const editor = vscode.window.activeTextEditor;\r\n\r\n    if (!editor) {\r\n        vscode.window.showErrorMessage('No active editor found. Please open the page you want to run.');\r\n        return;\r\n    }\r\n\r\n    const selection = editor.selection;\r\n    const selectedLine = selection.active.line + 1;\r\n\r\n    generateInlineComments();\r\n\r\n    vscode.window.showInformationMessage('Inline comment added.');\r\n}\r\n","import * as vscode from 'vscode';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport async function generateKubernetesFiles() {\r\n    if (!vscode.workspace.workspaceFolders) {\r\n        vscode.window.showErrorMessage('No workspace is open.');\r\n        return;\r\n    }\r\n\r\n    // Namespace Input \r\n    const namespaceInput = await vscode.window.showInputBox({\r\n      prompt: 'Your Namespace:',\r\n      placeHolder: 'Example: my-application',\r\n    });\r\n\r\n    \r\n    if (!namespaceInput) {\r\n      vscode.window.showWarningMessage('Please specify a namespace.');\r\n      return;\r\n    }\r\n\r\n    const namespace = checkSpacesAndReplace([namespaceInput])\r\n\r\n    // Deployment Input \r\n    const deploymentsInput = await vscode.window.showInputBox({\r\n      prompt: 'Your Deployment Files:',\r\n      placeHolder: 'Example: frontend, backend, redis ',\r\n    });\r\n\r\n    if (!deploymentsInput) {\r\n      vscode.window.showWarningMessage('Please specify atleast one deployment name.');\r\n      return;\r\n  }\r\n\r\n    const deploymentNames = checkSpacesAndReplace(deploymentsInput.split(',').map(name => name.trim()));\r\n\r\n    // Jobs Input \r\n    const jobsInput = await vscode.window.showInputBox({\r\n      prompt: 'Your Jobs:',\r\n      placeHolder: 'Example: collector, pickle (Give blank if you dont have job.',\r\n    });\r\n\r\n    if (!jobsInput) {\r\n      vscode.window.showInformationMessage('Jobs Folder not created.');\r\n      \r\n  } \r\n    \r\n\r\n    // Folder Generation\r\n    const kubernetesFolder = vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, 'kubernetes');\r\n        fs.mkdirSync(kubernetesFolder.fsPath, { recursive: true });\r\n\r\n    for(const deployment of deploymentNames){\r\n        const deploymentFolder = vscode.Uri.joinPath(kubernetesFolder, `${deployment}-service`);\r\n        fs.mkdirSync(deploymentFolder.fsPath, { recursive: true });\r\n    }\r\n        \r\n    const configmapsFolder = vscode.Uri.joinPath(kubernetesFolder, 'configmaps');\r\n    fs.mkdirSync(configmapsFolder.fsPath, { recursive: true });\r\n\r\n    const secretsFolder = vscode.Uri.joinPath(kubernetesFolder, 'secrets');\r\n    fs.mkdirSync(secretsFolder.fsPath, { recursive: true });\r\n\r\n    \r\n\r\n    // Deployment Yaml fs operations\r\n    const namespaceYAML = `\r\napiVersion: v1\r\nkind: Namespace\r\nmetadata:\r\n  name:\r\n   ${namespace}`;\r\n    fs.writeFileSync(path.join(kubernetesFolder.fsPath, 'namespace.yaml'), namespaceYAML);\r\n\r\n    const promises = deploymentNames.map(async deploymentName => {\r\n    const serviceFolder = vscode.Uri.joinPath(kubernetesFolder, `${deploymentName}-service`);\r\n    const deploymentYAML = `\r\napiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: ${deploymentName}\r\n  namespace: ${namespace}\r\nspec:\r\n  replicas: 3\r\n  selector:\r\n    matchLabels:\r\n      app: my-app\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: my-app\r\n    spec:\r\n      containers:\r\n        - name: my-container\r\n          image: nginx:latest\r\n          ports:\r\n            - containerPort: 80\r\n          `;\r\n    await writeFileWithDirectoryCheck(path.join(serviceFolder.fsPath, `${deploymentName}-deployment.yaml`), deploymentYAML);\r\n\r\n    const serviceYAML = `\r\napiVersion: v1\r\nkind: Service\r\nmetadata:\r\nname: ${deploymentName}-service\r\nnamespace: ${namespace}\r\nspec:\r\nselector:\r\n  app: ${deploymentName}\r\nports:\r\n  - protocol: TCP\r\n    port: 80\r\n    targetPort: 8080\r\n          `;\r\n    await writeFileWithDirectoryCheck(path.join(serviceFolder.fsPath, `${deploymentName}-service.yaml`), serviceYAML);\r\n\r\n    const ingressYAML = `\r\napiVersion: networking.k8s.io/v1\r\nkind: Ingress\r\nmetadata:\r\nname: ${deploymentName}-ingress\r\nnamespace: ${namespace}\r\nspec:\r\nrules:\r\n  - host: ${deploymentName}.com\r\n    http:\r\n      paths:\r\n        - path: /\r\n          pathType: Prefix\r\n          backend:\r\n            service:\r\n              name: ${deploymentName}-service\r\n              port:\r\n                number: 80\r\n          `;\r\n    await writeFileWithDirectoryCheck(path.join(serviceFolder.fsPath, `${deploymentName}-ingress.yaml`), ingressYAML);\r\n});\r\n    const secretYAML = `\r\napiVersion: v1\r\nkind: Secret\r\nmetadata:\r\n  name: application-secret\r\n  namespace: ${namespace}\r\ntype: Opaque\r\ndata:\r\n  username: ${Buffer.from('my-username').toString('base64')}\r\n  password: ${Buffer.from('my-password').toString('base64')}\r\n          `;\r\n    await writeFileWithDirectoryCheck(path.join(secretsFolder.fsPath, `application-secret.yaml`), secretYAML);\r\n\r\n    const configMapYAML = `\r\napiVersion: v1\r\nkind: ConfigMap\r\nmetadata:\r\n  name: application-configmap\r\n  namespace: ${namespace}\r\ndata:\r\n  config.properties: |\r\n    key1=value1\r\n    key2=value2\r\n            `;\r\n    await writeFileWithDirectoryCheck(path.join(configmapsFolder.fsPath, `application-configmap.yaml`), configMapYAML);\r\n\r\n    await Promise.all(promises);\r\n    vscode.window.showInformationMessage(`${deploymentNames.length} deployment, service, and ingress files generated successfully.`);\r\n\r\n    // Jobs Yaml fs operations\r\n    if(jobsInput){\r\n      const jobsFolder = vscode.Uri.joinPath(kubernetesFolder, 'jobs');\r\n      fs.mkdirSync(jobsFolder.fsPath, { recursive: true });\r\n      \r\n      const jobNames = checkSpacesAndReplace(jobsInput.split(',').map(name => name.trim()));\r\n    \r\n      const jobPromises = jobNames.map(async jobName => {\r\n      const jobYAML = `\r\napiVersion: batch/v1\r\nkind: Job\r\nmetadata:\r\n  name: ${jobName}\r\nspec:\r\n  completions: 1\r\n  template:\r\n    metadata:\r\n      name: ${jobName}-pod\r\n    spec:\r\n      containers:\r\n        - name: ${jobName}-container\r\n          image: nginx\r\n      restartPolicy: Never\r\n  \r\n        `;\r\n      await writeFileWithDirectoryCheck(path.join(jobsFolder.fsPath, `${jobName}-job.yaml`), jobYAML);\r\n  })\r\n    await Promise.all(jobPromises);\r\n    vscode.window.showInformationMessage(`${jobNames.length} deployment, service, and ingress files generated successfully.`);\r\n  }\r\n}\r\n  \r\nasync function writeFileWithDirectoryCheck(filePath: string, content: string) {\r\n  const folderPath = path.dirname(filePath);\r\n  await fs.promises.mkdir(folderPath, { recursive: true });\r\n  await fs.promises.writeFile(filePath, content);\r\n}\r\n\r\nfunction checkSpacesAndReplace(variableList: string[]){\r\n  return variableList.map((item) => item.replace(/ +/g, '_'))\r\n}","import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { generateInlineCommands } from './commands/generateInlineCommands';\r\nimport { generateDockerFiles } from './commands/generateDockerFiles';\r\nimport { generateKubernetesFiles } from './commands/generateKubernetesFiles';\r\nimport { generateDockerComposeYaml } from './commands/generateDockerComposeYaml'\r\n\r\nexport function activate(context: vscode.ExtensionContext) {\r\n    console.log('Backdoor extension is now active.');\r\n    vscode.window.showInformationMessage('Important: Use CTRL + i for open extension UI.');\r\n    //Get config values\r\n    const config = vscode.workspace.getConfiguration('compose-core');\r\n    const dockerComposeAutorun = config.get('dockerComposeAutorun');\r\n    // Register commands\r\n    context.subscriptions.push(\r\n        vscode.commands.registerCommand('compose-core.generateInlineCommands', generateInlineCommands),\r\n        vscode.commands.registerCommand('compose-core.generateDockerFiles', generateDockerFiles),\r\n        vscode.commands.registerCommand('compose-core.composeCoreDashboardInit', showBackdoorDashboard),\r\n        vscode.commands.registerCommand('compose-core.generateKubernetesFiles', generateKubernetesFiles),\r\n        vscode.commands.registerCommand('compose-core.generateDockerComposeYaml', async () => {\r\n            if (typeof dockerComposeAutorun === 'boolean') {\r\n                await generateDockerComposeYaml(dockerComposeAutorun);\r\n            } else {\r\n                vscode.window.showErrorMessage('Invalid value for dockerComposeAutorun.');\r\n            }\r\n        })\r\n    );\r\n}\r\n\r\nasync function showBackdoorDashboard() {\r\n    const panel = vscode.window.createWebviewPanel(\r\n        'backdoorUI',\r\n        'Backdoor UI',\r\n        vscode.ViewColumn.One,\r\n        {}\r\n    );\r\n\r\n    panel.webview.html = getWebviewContent(panel.webview);\r\n\r\n}\r\n\r\nfunction getWebviewContent(webview: vscode.Webview): string {\r\n    const buttonStyle = 'padding: 6px 12px; font-size: 16px; background-color:#313131; border-radius:7px; border:1px solid white; color:white; margin: 10px;';\r\n    const extensionPath = vscode.extensions.getExtension('Latrodect.compose-core')?.extensionPath || '';\r\n    return `\r\n        <!DOCTYPE html>\r\n        <html lang=\"en\">\r\n        <head>\r\n            <meta charset=\"UTF-8\">\r\n            <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src ${webview.cspSource} 'unsafe-inline' 'unsafe-eval';\">\r\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n            <title>Backdoor Code Reviewer</title>\r\n        </head>\r\n        <body>\r\n            <div style=\"display:flex;\">\r\n            <h1>Backdoor Code Reviewer</h1>\r\n            </div>\r\n            <p style=\"color:white;\"> Backdoor is a free code reviewer assistant. It helps developers with AI support, increases code quality with highlighter and linter features.<p>\r\n            <br>\r\n            <hr>\r\n            <h2>How to Generate docker-compose.yaml File</h2>\r\n            <p style=\"color:white;\"> If autorun enabled, make sure <stron>docker compose</strong> setup correctly. <p>\r\n            <p style=\"color:white;\"> Type CTRL + SHIFT + P and select <strong>Backdoor Docker Compose: Generate Docker Compose YAML</strong>. Provide how many services do you have. <p>\r\n            <p style=\"color:white;\"> Type your service name and port. After that step specify your environment variables. <p>\r\n            <p style=\"color:white;\"> Apply this steps for each service. <p>\r\n            <p style=\"color:white;\"> Your <strong>docker-compose.yaml</strong> will be created. Happy coding !!! <p>\r\n\r\n            <hr>\r\n\r\n            <h2>How to Generate Docker Files</h2>\r\n            <p style=\"color:white;\"> Type CTRL + SHIFT + P and select <strong>Backdoor Docker: Generate Docker files</strong>. Provide information about root of your project. <p>\r\n            <p style=\"color:white;\"> Type your application names which exist on your root.  <p>\r\n            <p style=\"color:white;\"> Your <strong>Dockerfiles</strong> will be created and we create a bash script for you. Happy building !!! <p>\r\n\r\n            <hr>\r\n\r\n            <h2>How to Generate Kubernetes Files</h2>\r\n            <p style=\"color:white;\"> Type CTRL + SHIFT + P and select <strong>Backdoor Kubernetes: Generate K8S files</strong>.  <p>\r\n            <p style=\"color:white;\"> Provide information about your services.  <p>\r\n            <p style=\"color:white;\"> Your <strong>k8s yaml</strong> and <strong>folder structure</strong> will be created. Happy deployment !!! <p>\r\n            <script src=\"${webview.asWebviewUri(vscode.Uri.file(__dirname + '/script.js'))}\"></script>\r\n        </body>\r\n        </html>\r\n    `;\r\n}\r\n\r\nexport function deactivate() {\r\n    console.log('Backdoor Code Reviewer extension is now deactivated.');\r\n}\r\n","import * as vscode from 'vscode';\r\n// import axios from 'axios';\r\n\r\nexport async function generateInlineComments() {\r\n    const editor = vscode.window.activeTextEditor;\r\n    if (!editor) {\r\n        vscode.window.showErrorMessage('No active editor found.');\r\n        return;\r\n    }\r\n\r\n    const selectedCode = getSelectedCode(editor);\r\n    if (!selectedCode) {\r\n        vscode.window.showInformationMessage('No code is selected.');\r\n        return;\r\n    }\r\n    // await generateComment(selectedCode);\r\n    const generatedComment = \"Axios will be added soon.\"\r\n    insertComment(editor, generatedComment);\r\n}\r\n\r\nfunction getSelectedCode(editor: vscode.TextEditor): string | undefined {\r\n    const selection = editor.selection;\r\n    if (selection.isEmpty) {\r\n        return undefined;\r\n    }\r\n\r\n    return editor.document.getText(selection);\r\n}\r\n\r\n// async function generateComment(code: string): Promise<string> {\r\n//     const apiKey = await vscode.window.showInputBox({\r\n//         prompt: 'ChatGPT API Key',\r\n//         placeHolder: 'sk-..JKuaJ',\r\n//       });\r\n//     const prompt = `Code to review:\\n\\n${code}\\n\\nPlease provide a comment for this code.`;\r\n\r\n//     try {\r\n//         const response = await axios.post(\r\n//             'https://api.openai.com/v1/engines/davinci-codex/completions',\r\n//             {\r\n//                 prompt,\r\n//                 max_tokens: 50, \r\n//             },\r\n//             {\r\n//                 headers: {\r\n//                     'Content-Type': 'application/json',\r\n//                     'Authorization': `Bearer ${apiKey}`,\r\n//                 },\r\n//             }\r\n//         );\r\n\r\n//         return response.data.choices[0].text.trim();\r\n//     } catch (error) {\r\n//         console.error('Error generating comment:', error);\r\n//         return 'Unable to generate comment at the moment.';\r\n//     }\r\n// }\r\n\r\nfunction insertComment(editor: vscode.TextEditor, comment: string) {\r\n    const selection = editor.selection;\r\n    const position = selection.end;\r\n    editor.edit(editBuilder => {\r\n        editBuilder.insert(position, '\\n// Generated Comment: ' + comment);\r\n    });\r\n\r\n    vscode.window.showInformationMessage('Comment generated and inserted.');\r\n}\r\n","module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(112);\n"],"names":["generateDockerComposeYaml","autorunBool","vscode","workspace","workspaceFolders","window","showErrorMessage","inputServiceCount","showInputBox","prompt","placeHolder","trim","serviceCount","parseInt","Number","isNaN","showWarningMessage","serviceList","envList","index","serviceInformation","service","checkSpacesAndReplace","split","map","name","length","environmentVariables","showInformationMessage","formattedEnvironmentVar","varName","process","env","push","dockerComposeFolder","Uri","joinPath","uri","fs","mkdirSync","fsPath","recursive","dockerComposeData","version","services","serviceName","port","formattedEnvironmentStrings","entry","join","build","context","dockerfile","ports","volumes","environment","yamlContent","Object","entries","serviceData","dockerComposeYamlPath","path","filePath","content","folderPath","dirname","promises","mkdir","writeFile","writeFileWithDirectoryCheck","getConfiguration","get","console","log","workspaceDir","terminal","createTerminal","cwd","sendText","show","variableList","item","replace","module","exports","findApplicationFolder","projectRoot","applicationName","statSync","isDirectory","error","contApplicaitons","dockerFolder","scriptsFolder","dockerApplicationsPath","scriptContent","scriptFilePath","dockerApplications","appName","appFolder","dockerFileContent","dockerFilePath","editor","activeTextEditor","selection","active","line","generateInlineComments","namespaceInput","namespace","deploymentsInput","deploymentNames","jobsInput","kubernetesFolder","deployment","deploymentFolder","configmapsFolder","secretsFolder","namespaceYAML","writeFileSync","deploymentName","serviceFolder","deploymentYAML","serviceYAML","ingressYAML","secretYAML","Buffer","from","toString","configMapYAML","Promise","all","jobsFolder","jobNames","jobPromises","jobName","jobYAML","showBackdoorDashboard","panel","createWebviewPanel","ViewColumn","One","webview","html","extensions","getExtension","extensionPath","cspSource","asWebviewUri","file","__dirname","dockerComposeAutorun","subscriptions","commands","registerCommand","generateInlineCommands","generateDockerFiles","generateKubernetesFiles","selectedCode","isEmpty","document","getText","getSelectedCode","comment","position","end","edit","editBuilder","insert","insertComment","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}